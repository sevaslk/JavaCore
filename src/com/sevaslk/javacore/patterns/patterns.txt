================= порождающие ====================
FactoryMethod
Организация логики на уровне интерфейсов, вынесение создания объекта в отдельный метод

AbstractFactory
"Оркестратор" фабричных методов

Builder
Создается объект в отдельном классе, каждый параметр объекта сеттится в отдельном методе, геттер возвращает готовый объект.

Prototype
Копирование объекта через Object temp

Singleton
Создание единственного экземпляра класса. В статическом методе проверяется наличие объекта. Если он уже создавался, то возвращает его же, если нет - создается новый.

================= структурные ====================

Adapter
Промежуточный класс, связывает две разные структуры, перенаправляет вызов метода.

Bridge
Объединяет типы на уровне абстракций, один другому передается в качестве параметра

Composite
Создается структура, где в качестве ноды может выступать контейнер нод, внутри которого элементы обрабатываются теми же методами (в цикле).

Decorator
BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));

Facade
Инкапсуляция в отдельном классе нескольких методов другого класса, в одном методе и необходимых полей для работы метода фасада.

Flyweight
Создается "кэш" объектов. При потребности в новом объекте проверяется кэш и  при наличии объект возвраается оттуда, иначе - возвращается вновьсозданный объект.

Proxy
proxy, simple proxy

================= поведенческие ====================

Chain of Responsibility
Создается несколько прокси, в каждом из которых может существовать своя логика обработки вызова.

Command
Вызов метода => объект. Не до конца разобрался.

Iterator
Реализация итератора и необходимых методов для конкретного набора объектов.

Mediator
Реализация класса, в котором находятся все ссылки из нескольких независимых типов и логика обработки\распределения вызовов между ними.

Memento
Сохранение состояния полей одного объекта в другом.

Observer
Создание коллекции объектов-наблюдателей за объектом и вызов их в случае изменения состояния объекта наблюдения. (Observed.notify => Oserver.handleEvent)

State
Создание нескольких классов, соответствующих определенному состоянию объекта. Логика переключения может находиться либо в классе-контексте, либо в классе-состоянии.(нужно еще разбираться)

Strategy
Создается класс, в котором хранится состояние. Конкретная реализация состояния передается объекту в виде параметра.

Template Method
Вынос общей логики в абстрактный класс. Убирает дублирование.

Visitor
Объект1(Объект2) => Объект2(Объект1).делатьЧто-то()